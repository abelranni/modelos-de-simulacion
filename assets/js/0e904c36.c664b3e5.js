"use strict";(self.webpackChunkmodelos_de_simulacion=self.webpackChunkmodelos_de_simulacion||[]).push([[6664],{7457:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/banco_salabim_fase_2","metadata":{"permalink":"/modelos-de-simulacion/blog/banco_salabim_fase_2","source":"@site/blog/banco_salabim_fase_2.md","title":"banco_salabim_fase_2","description":"El ejemplo de la oficina bancaria con resistir y renegar\uf0c1","date":"2023-05-17T21:47:26.000Z","formattedDate":"17 de mayo de 2023","tags":[],"readingTime":5.78,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"nextItem":{"title":"Bienvenida","permalink":"/modelos-de-simulacion/blog/welcome"}},"content":"## El ejemplo de la oficina bancaria con resistir y renegar[\uf0c1](https://www.salabim.org/manual/Modelling.html#the-bank-office-example-with-balking-and-reneging \\"Permalink to this heading\\")\\n\\nAhora, asumimos que los clientes no van a la cola cuando hay m\xe1s de 5 clientes esperando (balking). Adem\xe1s de eso, si un cliente est\xe1 esperando m\xe1s de 50, \xe9l / ella Irse tambi\xe9n (renegar).\\n\\nEl c\xf3digo del modelo es:\\n\\n```python\\n# Example - bank, 3 clerks, reneging.py\\nimport salabim as sim\\n\\n\\nclass CustomerGenerator(sim.Component):\\n    def process(self):\\n        while True:\\n            Customer()\\n            yield self.hold(sim.Uniform(5, 15).sample())\\n\\n\\nclass Customer(sim.Component):\\n    def process(self):\\n        if len(waitingline) >= 5:\\n            env.number_balked += 1\\n            env.print_trace(\\"\\", \\"\\", \\"balked\\")\\n            print(env.now(), \\"balked\\",self.name())            \\n            yield self.cancel()\\n        self.enter(waitingline)\\n        for clerk in clerks:\\n            if clerk.ispassive():\\n                clerk.activate()\\n                break  # activate only one clerk\\n        yield self.hold(50)  # if not serviced within this time, renege\\n        if self in waitingline:\\n            self.leave(waitingline)\\n            env.number_reneged += 1\\n            env.print_trace(\\"\\", \\"\\", \\"reneged\\")\\n        else:\\n            yield self.passivate()  # wait for service to be completed\\n\\n\\nclass Clerk(sim.Component):\\n    def process(self):\\n        while True:\\n            while len(waitingline) == 0:\\n                yield self.passivate()\\n            self.customer = waitingline.pop()\\n            self.customer.activate()  # get the customer out of it\'s hold(50)\\n            yield self.hold(30)\\n            self.customer.activate()  # signal the customer that\'s all\'s done\\n\\n\\nenv = sim.Environment()\\nCustomerGenerator()\\nenv.number_balked = 0\\nenv.number_reneged = 0\\nclerks = [Clerk() for _ in range(3)]\\n\\nwaitingline = sim.Queue(\\"waitingline\\")\\nenv.run(duration=300000)\\nwaitingline.length.print_histogram(30, 0, 1)\\nwaitingline.length_of_stay.print_histogram(30, 0, 10)\\nprint(\\"number reneged\\", env.number_reneged)\\nprint(\\"number balked\\", env.number_balked)\\n\\n```\\n\\nVeamos algunos detalles.\\n\\nEsto hace que el componente actual (un cliente) sea un componente de datos (y est\xe9 sujeto a recolecci\xf3n de elementos no utilizados), si la longitud de la cola es 5 o m\xe1s.\\n\\nEl renegamiento se implementa mediante una retenci\xf3n de 50. Si un empleado puede atender a un cliente, tomar\xe1 El cliente sale de la l\xednea de espera y la activar\xe1 en ese momento. El cliente solo tiene que comprobar si \xe9l / ella todav\xeda est\xe1 en la fila de espera. Si es as\xed, \xe9l / ella no ha sido atendido a tiempo y, por lo tanto, renegar\xe1.\\n\\n```python\\nyield self.hold(50)\\nif self in waitingline:\\n    self.leave(waitingline)\\n    env.number_reneged += 1\\nelse:\\n     self.passivate()\\n\\n```\\n\\nTodo lo que el empleado tiene que hacer al comenzar a atender a un cliente es hacer que el siguiente cliente se alinee. Salga de la cola (como antes) y active este cliente (a la hora ahora). El efecto es que la retenci\xf3n del cliente terminar\xe1.\\n\\n```python\\nself.customer = waitingline.pop()\\nself.customer.activate()\\n\\n```\\n\\n## El ejemplo de la oficina bancaria con resistir y renegar (tienda)[\uf0c1](https://www.salabim.org/manual/Modelling.html#the-bank-office-example-with-balking-and-reneging-store \\"Permalink to this heading\\")\\n\\nAhora mostramos c\xf3mo se implementa el rechazo y el renego con una tienda.\\n\\nEl c\xf3digo del modelo es:\\n\\n```python\\n# Bank, 3 clerks (store, reneging).py\\nimport salabim as sim\\n\\n\\nclass CustomerGenerator(sim.Component):\\n    def process(self):\\n        while True:\\n            customer = Customer()\\n            yield self.to_store(waiting_room, customer, fail_at=env.now())\\n            if self.failed():\\n                customer.cancel()\\n                env.number_balked += 1\\n                print(env.now(), \\"balked\\",customer.name())\\n                env.print_trace(\\"\\", \\"\\", \\"balked\\",customer.name())\\n            yield self.hold(sim.Uniform(5, 15))\\n\\n\\nclass Clerk(sim.Component):\\n    def process(self):\\n        while True:\\n            customer = yield self.from_store(waiting_room)\\n            yield self.hold(30)\\n\\n\\nclass Customer(sim.Component):\\n    def process(self):\\n        yield self.hold(50)\\n        if self in waiting_room:\\n            self.leave(waiting_room)\\n            env.number_reneged += 1\\n            env.print_trace(\\"\\", \\"\\", \\"reneged\\")\\n\\nenv = sim.Environment(trace=False)\\nenv.number_balked = 0\\nenv.number_reneged = 0\\nCustomerGenerator()\\nfor _ in range(3):\\n    Clerk()\\nwaiting_room = sim.Store(\\"waiting_room\\", capacity=5)\\n\\nenv.run(till=30000)\\n\\nwaiting_room.length.print_histogram(30, 0, 1)\\nwaiting_room.length_of_stay.print_histogram(30, 0, 10)\\nprint(\\"number reneged\\", env.number_reneged)\\nprint(\\"number balked\\", env.number_balked)\\n\\n```\\n\\nComo puede ver, la parte de resistencia se realiza estableciendo un valor de fail\\\\_at de 0 en el to\\\\_store, lo que significa que si la solicitud no se atiende inmediatamente, El cliente se resiste.\\n\\nPara el renacimiento, hacemos lo mismo que con la soluci\xf3n ordinaria.\\n\\n## El ejemplo de la oficina bancaria con resistir y renegar (recursos)[\uf0c1](https://www.salabim.org/manual/Modelling.html#the-bank-office-example-with-balking-and-reneging-resources \\"Permalink to this heading\\")\\n\\nAhora mostramos c\xf3mo el rechazo y la renegaci\xf3n se implementan con recursos.\\n\\nEl c\xf3digo del modelo es:\\n\\n```python\\n# Example - bank, 3 clerks, reneging (resources).py\\nimport salabim as sim\\n\\n\\nclass CustomerGenerator(sim.Component):\\n    def process(self):\\n        while True:\\n            Customer()\\n            yield self.hold(sim.Uniform(5, 15).sample())\\n\\n\\nclass Customer(sim.Component):\\n    def process(self):\\n        if len(clerks.requesters()) >= 5:\\n            env.number_balked += 1\\n            env.print_trace(\\"\\", \\"\\", \\"balked\\")\\n            yield self.cancel()\\n        yield self.request(clerks, fail_delay=50)\\n        if self.failed():\\n            env.number_reneged += 1\\n            env.print_trace(\\"\\", \\"\\", \\"reneged\\")\\n        else:\\n            yield self.hold(30)\\n            self.release()\\n\\n\\nenv = sim.Environment()\\nCustomerGenerator()\\nenv.number_balked = 0\\nenv.number_reneged = 0\\nclerks = sim.Resource(\\"clerks\\", 3)\\n\\nenv.run(till=50000)\\n\\nclerks.requesters().length.print_histogram(30, 0, 1)\\nprint()\\nclerks.requesters().length_of_stay.print_histogram(30, 0, 10)\\nprint(\\"number reneged\\", env.number_reneged)\\nprint(\\"number balked\\", env.number_balked)\\n\\n```\\n\\nComo puede ver, la parte de resistencia es exactamente la misma que en el ejemplo sin recursos.\\n\\nPara el reenging, todo lo que tenemos que hacer es agregar un fail\\\\_delay\\n\\n```python\\nyield self.request(clerks, fail_delay=50)\\n\\n```\\n\\nSi la solicitud no se cumple dentro de las 50 unidades de tiempo, el proceso contin\xfaa despu\xe9s de esa declaraci\xf3n de solicitud. Y luego, simplemente verificamos si la solicitud ha fallado\\n\\n```python\\nif self.failed():\\n    env.number_reneged += 1\\n\\n```\\n\\nEste ejemplo muestra claramente la ventaja de la soluci\xf3n de recursos sobre el m\xe9todo pasivar/activate, en este ejemplo.\\n\\n## El ejemplo de la oficina bancaria con estados[\uf0c1](https://www.salabim.org/manual/Modelling.html#the-bank-office-example-with-states \\"Permalink to this heading\\")\\n\\nEl paquete salabim contiene otro concepto \xfatil para el modelado: estados. En este caso, definimos un estado llamado worktodo.\\n\\nEl c\xf3digo del modelo es:\\n\\n```python\\n# Example - bank, 3 clerks (state).py\\nimport salabim as sim\\n\\n\\nclass CustomerGenerator(sim.Component):\\n    def process(self):\\n        while True:\\n            Customer()\\n            yield self.hold(sim.Uniform(5, 15).sample())\\n\\n\\nclass Customer(sim.Component):\\n    def process(self):\\n        self.enter(waitingline)\\n        worktodo.trigger(max=1)\\n        yield self.passivate()\\n\\n\\nclass Clerk(sim.Component):\\n    def process(self):\\n        while True:\\n            if len(waitingline) == 0:\\n                yield self.wait((worktodo, True, 1))\\n            self.customer = waitingline.pop()\\n            yield self.hold(30)\\n            self.customer.activate()\\n\\n\\nenv = sim.Environment()\\nCustomerGenerator()\\nfor i in range(3):\\n    Clerk()\\nwaitingline = sim.Queue(\\"waitingline\\")\\nworktodo = sim.State(\\"worktodo\\")\\n\\nenv.run(till=50000)\\nwaitingline.print_histograms()\\nworktodo.print_histograms()\\n\\n```\\n\\nVeamos algunos detalles.\\n\\n```python\\nworktodo = sim.State(\'worktodo\')\\n\\n```\\n\\nEsto define un estado con un valor inicial False.\\n\\nEn el c\xf3digo del cliente, el cliente intenta activar un empleado con\\n\\nEl efecto es que si hay empleados esperando trabajo, la espera del primer empleado es honrada y Ese empleado contin\xfaa su proceso despu\xe9s de\\n\\n```python\\nyield self.wait(worktodo)\\n\\n```\\n\\nTenga en cuenta que el empleado solo va a esperar a trabajar despu\xe9s de completar un trabajo si hay no hay clientes esperando.\\n\\n## El ejemplo de la oficina bancaria con standby[\uf0c1](https://www.salabim.org/manual/Modelling.html#the-bank-office-example-with-standby \\"Permalink to this heading\\")\\n\\nEl paquete salabim contiene otro poderoso mecanismo de proceso, llamado standby. Cuando un componente est\xe1 en modo de espera, se actualizar\xe1 despu\xe9s de _cada_ evento. Normalmente, el modo de espera ser\xe1 Se utiliza en un bucle WHILE donde en cada evento se comprueban una o m\xe1s condiciones.\\n\\nEl modelo con standby es\\n\\n```python\\n# Example - bank, 3 clerks (standby).py\\nimport salabim as sim\\n\\n\\nclass CustomerGenerator(sim.Component):\\n    def process(self):\\n        while True:\\n            Customer()\\n            yield self.hold(sim.Uniform(5, 15).sample())\\n\\n\\nclass Customer(sim.Component):\\n    def process(self):\\n        self.enter(waitingline)\\n        yield self.passivate()\\n\\n\\nclass Clerk(sim.Component):\\n    def process(self):\\n        while True:\\n            while len(waitingline) == 0:\\n                yield self.standby()\\n            self.customer = waitingline.pop()\\n            yield self.hold(30)\\n            self.customer.activate()\\n\\n\\nenv = sim.Environment(trace=True)\\nCustomerGenerator()\\nfor _ in range(3):\\n    Clerk()\\nwaitingline = sim.Queue(\\"waitingline\\")\\n\\nenv.run(till=50000)\\nwaitingline.length.print_histogram(30, 0, 1)\\nprint()\\nwaitingline.length_of_stay.print_histogram(30, 0, 10)\\n\\n```\\n\\nEn este caso, la condici\xf3n se verifica con frecuencia con\\n\\n```python\\nwhile len(waitingline) == 0:\\n    yield self.standby()\\n\\n```\\n\\nEl resto del c\xf3digo es muy similar a la versi\xf3n con estados.\\n\\nAdvertencia\\n\\nEs muy importante darse cuenta de que este mecanismo puede tener un impacto significativo en el rendimiento, como despu\xe9s de CADA evento, el componente se vuelve actual y debe verificarse. En general, se recomienda intentar usar estados o un pasivo / activar m\xe1s directo. construcci\xf3n."},{"id":"welcome","metadata":{"permalink":"/modelos-de-simulacion/blog/welcome","source":"@site/blog/2023-04-10-bienvenida/index.md","title":"Bienvenida","description":"Las funciones de blogging de Docusaurus funcionan con el plugin de blog.","date":"2023-04-10T00:00:00.000Z","formattedDate":"10 de abril de 2023","tags":[{"label":"lenguajes","permalink":"/modelos-de-simulacion/blog/tags/lenguajes"},{"label":"c","permalink":"/modelos-de-simulacion/blog/tags/c"},{"label":"intro","permalink":"/modelos-de-simulacion/blog/tags/intro"}],"readingTime":0.28,"hasTruncateMarker":false,"authors":[{"name":"Abel Ranni","title":"Developer","url":"https://github.com/abelranni","imageURL":"https://avatars.githubusercontent.com/u/13169667?v=4","key":"abel"}],"frontMatter":{"slug":"welcome","title":"Bienvenida","authors":["abel"],"tags":["lenguajes","c","intro"]},"prevItem":{"title":"banco_salabim_fase_2","permalink":"/modelos-de-simulacion/blog/banco_salabim_fase_2"}},"content":"Las [funciones de blogging de Docusaurus](https://docusaurus.io/docs/blog) funcionan con el [plugin de blog](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog).\\n\\nSimplemente a\xf1ada archivos Markdown (o carpetas) al directorio `blog`.\\n\\nLos autores habituales del blog pueden a\xf1adirse a `authors.yml`.\\n\\nLa fecha de la entrada del blog se puede extraer de los nombres de archivo, tales como:\\n\\n- `2019-05-30-bienvenida.md`\\n- `2019-05-30-welcome/index.md`\\n\\nEl blog tambi\xe9n admite etiquetas."}]}')}}]);